dynamic programming

분할 정복 vs dp
- 둘다 큰거 -> 작은거로 나눠서 다시 merge하는 방식
- 분할정복은 서로 공유하지 않는 독립적인 소문제들로 나눠져야함.
- dp는 서로 독립되지 않아야함. -> 나눠진 소문제들이 같은 문제를 공유해야함.

dp를 설계하는 과정

1. 부분 문제의 정의 
    -> 배열의 각 인자들의 의미 설정 
    -> ex : dp = [0] * 100 
        -> 여기서 이 배열은 뭐지? dp[i]은 뭘 의미하지? 이런거를 정의
    -> 문제의 요구사항을 정확하게, 풀고자 하는 알고리즘을 잘 설정해야함.
    -> 배열에 저장되는 값이 무엇인지 설정 해야함.

2. 설정한 부분 문제들 사이의 관계 정의 
    -> 재귀적으로 정의 해야함. 
        = 같은 코드가 인자만 바뀌어서 반복 되어야함.
    -> 부분 문제들을 이용해서 큰 문제가 꼭 풀려야함. 
        -> 큰 문제가 안 풀리면 잘못 설정된거임.
        -> np로 풀어야 되는 문제일수도 있음(dp가 모든 경우에 적용되는 것은 아님.) 
            -> 다만 요즘은 메모리 제약이 없어져서 거의 다 고차원 배열을 쓰는 고차원 dp로 풀림.
    -> 코딩을 바로 하는 것보다 식으로 미리 표현 하는게 좋음 
        -> 왠만하면 해야됨.
        -> 이 정의된 식을 보통 점화식이라고 함.

3. 답 찾기
    -> 탑 다운 + 재귀 호출로 점화식을 풀거나
        -> 노드를 예시로 들면, 한번 방문한 노드와 같은 값의 노드들은 방문하지 않는 방식
        -> 메모이제이션이라고 함.
        -> 큰 문제 분할 > 캐시를 통한 중복 계산 방지로 진행 됨.
        -> 필요한 것만 해결함.

    -> 바텀 업 + 반복문으로 풀수 있다.
        -> 작은 것 부터 미리 채워 넣는 방식
        -> 초기화 > 인덱스 키우기의 방식으로 진행됨
        -> 타블레이션이라고 함.
        -> 모든 하위 문제를 해결함.

    -> dp의 백트레킹 과정
        -> 보통 최적의 해 또는 최적의 해를 구하기 위한 과정을 구하기 위해 사용됨.

